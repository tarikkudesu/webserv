
# include "ServerEngine.hpp"

ServerEngine::ServerEngine( ) :
__configurationFile( "default_path.conf" ),
__sockNum( 0 )
{
	std::cout << "config file " << __configurationFile << "\n";
}

ServerEngine::ServerEngine( const String &configutation_file ) :
__configurationFile( configutation_file ),
__sockNum( 0 )
{
	std::cout << "config file " << __configurationFile << "\n";
}

ServerEngine::ServerEngine( const ServerEngine &engine )
{
	*this = engine;
}

ServerEngine	&ServerEngine::operator=( const ServerEngine& engine )
{
	if (this != &engine)
	{
		this->__configurationFile = engine.__configurationFile;
		this->__sockets = engine.__sockets;
		this->__servers = engine.__servers;
		this->__sockNum = engine.__sockNum;
	}
	return (*this);
}

ServerEngine::~ServerEngine( )
{
	for (t_events::iterator it = __sockets.begin(); it != __sockets.end(); it++) {
		close(it->fd);
	}
}

/******************************************************************************
 *                               MINI FUNCTIONS                               *
 ******************************************************************************/
bool	ServerEngine::isServerSock( int sd )
{
	for (size_t i = 0; i < this->__servers.size(); i++) {
		if (sd == this->__servers[i].__sd)
			return true;
	}
	return false;
}
void	ServerEngine::addClientSocket( int sd )
{
	struct pollfd	sockStruct;

	sockStruct.fd = sd;
	sockStruct.events = POLLIN | POLLOUT | POLLHUP;
	this->__sockets.push_back( sockStruct );
	this->__sockNum++;
}
void	ServerEngine::addServerSocket( int sd )
{
	struct pollfd	sockStruct;

	sockStruct.fd = sd;
	sockStruct.events = POLLIN;
	this->__sockets.push_back( sockStruct );
	this->__sockNum++;
}
void	ServerEngine::removeSocket( int sd )
{
	for (t_events::iterator it = __sockets.begin(); it != __sockets.end(); it++) {
		if (sd == it->fd) {
			this->__sockets.erase(it);
			this->__sockNum--;
			close(sd);
			break ;
		}
	}
}
/******************************************************************************
 *                               MAIN FUNCTIONS                               *
 ******************************************************************************/

void	ServerEngine::addNewConnection( struct pollfd &sockStruct )
{
	int		newSock;

	newSock = accept(sockStruct.fd, NULL, NULL);
	if (newSock >= 0) {
		addClientSocket( newSock );
		Server::setNonBlockingMode( newSock );
	} else {
		/*****************************
		 * ERROR TO BE HANDLED LATER *
		 *****************************/
		exit(EXIT_FAILURE);
	}
}
void	ServerEngine::readDataFromSocket( struct pollfd &sockStruct )
{
	char	buff[READ_SIZE];

	ssize_t bytesRead = recv(sockStruct.fd, buff, sizeof(buff), 0);
	if (bytesRead == 0) {
		closeConnection( sockStruct );
	} else if (bytesRead > 0) {
		/*********************************************
		 * CONTENT WILL BE SEND TO THE REQUEST PARSER *
		 * THEN TO THE RESPONSE BUILDER THEN SEND BACK *
		 ***********************************************/
		std::cout << bytesRead << " " << buff << "\n";
	} else {
		/*****************************
		 * ERROR TO BE HANDLED LATER *
		 *****************************/
		exit(EXIT_FAILURE);
	}
}
#include <string.h>
void	ServerEngine::writeDataToSocket( struct pollfd &sockStruct )
{
    const char* response = "HTTP/1.1 200 OK\n"
                        "Content-Type: text/html\n"
                        "Content-Length: 21\n"
                        "Connection: keep-alive\n\n"
                        "<h1>Hello world!</H1>";
	/**************************************************
	 * CONTENT MUST GENERATED BY THE RESPONCE BUILDER *
	 **************************************************/
	ssize_t	bytesWritten = send(sockStruct.fd, response, strlen(response), 0);
	if (bytesWritten > 0) {
		closeConnection( sockStruct );
		/*************************************************************
		 * THE CONNECTION IS NOT ALWAYS CLOSED JUST A TEMPORARY STAT *
		 *************************************************************/
	} else {
		/*****************************
		 * ERROR TO BE HANDLED LATER *
		 *****************************/
		exit(EXIT_FAILURE);
	}
}
void	ServerEngine::closeConnection( struct pollfd &sockStruct )
{
	removeSocket( sockStruct.fd );
}
void	ServerEngine::proccessPollEvent( )
{
	int			currSockNum = this->__sockNum;

	for (int sd = 0; sd < currSockNum; sd++)
	{
		struct pollfd &sockStruct = this->__sockets.at(sd);
		if (sockStruct.revents == 0)
			continue ;
		else if (sockStruct.revents & POLLIN)
		{
			if (isServerSock(sockStruct.fd))
				addNewConnection( sockStruct );
			else
				readDataFromSocket( sockStruct );
		} else if (sockStruct.revents & POLLOUT) {
			writeDataToSocket( sockStruct );
		} else if (sockStruct.revents & POLLHUP) {
			closeConnection( sockStruct );
		}
		currSockNum = this->__sockNum;
	}
}

void	ServerEngine::mainLoop( )
{
	int			retV = 0;

	try {
		while (true)
		{
			retV = poll(this->__sockets.data(), this->__sockets.size(), 0);
			if (retV == -1)
				throw std::runtime_error("poll syscall err");
			else if (retV == 0) {
				continue ;
			} else {
				this->proccessPollEvent();
			}
		}
	} catch ( std::exception &e ) {
		Logs::terr( e.what() );
	}
}
void	ServerEngine::setUpWebserv()
{
	/*******************************************************************************
	 *							  CREATE A CONF OBJECT, 						   *
	 *					 READ AND PARSE THE CONFIGURATION FILE, 				   *
	 *				SET UP EACH SERVER WITH ITS PORT, DOMAIN NAME ...			   *
	 * EACH SERVER MUST HAVE A LOCACTION CLASS CONFIGURED FROM THE LOCATION BLOCKS *
	 *                              HAKAROUUU, KHDMTK                              *
	 *******************************************************************************/

	Server	server1, server2, server3;
	server1.__port = 443;
	server2.__port = 444;
	server3.__port = 445;
	server1.__serverName = "domain1.com";
	server2.__serverName = "domain2.com";
	server3.__serverName = "domain3.com";
	this->__servers.push_back(server1);
	this->__servers.push_back(server2);
	this->__servers.push_back(server3);

	for (Servers::iterator it = __servers.begin(); it != __servers.end(); it++) {
		try {
			it->setup();
			this->addServerSocket( it->__sd );
		} catch ( std::exception &e ) {
			Logs::terr( e.what() );
		}
	}
}
